#!/usr/bin/env python3
"""
Rule generation module
Generates platform-specific firewall rules from JSON parameters
"""

import logging
from typing import Dict
from pathlib import Path

logger = logging.getLogger(__name__)


class RuleGenerator:
    """Generates firewall rules for multiple platforms"""
    
    def __init__(self, config: dict):
        """
        Initialize rule generator
        
        Args:
            config: Configuration dictionary
        """
        self.config = config
        self.template_dir = Path(config.get("templates", {}).get("directory", "templates"))
    
    def generate(self, rule_json: Dict, platform: str) -> str:
        """
        Generate a platform-specific firewall rule
        
        Args:
            rule_json: Parsed rule parameters
            platform: Target platform (pfSense, iptables, suricata, windows)
            
        Returns:
            Generated rule string
        """
        platform_lower = platform.lower()
        
        if platform_lower == "pfsense":
            return self._generate_pfsense(rule_json)
        elif platform_lower == "iptables":
            return self._generate_iptables(rule_json)
        elif platform_lower == "suricata":
            return self._generate_suricata(rule_json)
        elif platform_lower == "windows":
            return self._generate_windows(rule_json)
        else:
            raise ValueError(f"Unsupported platform: {platform}")
    
    def _generate_pfsense(self, rule: Dict) -> str:
        """Generate pfSense XML rule"""
        action_type = "block" if rule["action"] == "deny" else "pass"
        
        # Build source section
        src = rule["src_ip"]
        src_xml = f"<network>{src}</network>" if src != "any" else "<any/>"
        
        # Build destination section
        dst = rule["dst_ip"]
        dst_xml = f"<network>{dst}</network>" if dst != "any" else "<any/>"
        
        # Build port section
        port = rule["dst_port"]
        port_xml = f"<port>{port}</port>" if port != "any" else ""
        
        # Build protocol section
        proto = rule["proto"]
        proto_xml = proto if proto != "any" else "any"
        
        # Build schedule section (if time-based)
        schedule_xml = ""
        if rule["time_start"] != "00:00" or rule["time_end"] != "23:59":
            schedule_xml = f"""
  <schedule>
    <time>{rule["time_start"]}-{rule["time_end"]}</time>
  </schedule>"""
        
        xml = f"""<rule>
  <type>{action_type}</type>
  <interface>wan</interface>
  <ipprotocol>inet</ipprotocol>
  <protocol>{proto_xml}</protocol>
  <source>
    {src_xml}
  </source>
  <destination>
    {dst_xml}
    {port_xml}
  </destination>{schedule_xml}
  <descr>Auto-generated by AI Firewall Rule-Miner</descr>
</rule>"""
        
        return xml
    
    def _generate_iptables(self, rule: Dict) -> str:
        """Generate iptables command"""
        action = "DROP" if rule["action"] == "deny" else "ACCEPT"
        
        # Build base command
        cmd = "iptables -A INPUT"
        
        # Add source IP
        if rule["src_ip"] != "any":
            cmd += f" -s {rule['src_ip']}"
        
        # Add destination IP
        if rule["dst_ip"] != "any":
            cmd += f" -d {rule['dst_ip']}"
        
        # Add protocol
        if rule["proto"] != "any":
            cmd += f" -p {rule['proto']}"
        
        # Add destination port
        if rule["dst_port"] != "any" and rule["proto"] in ["tcp", "udp"]:
            cmd += f" --dport {rule['dst_port']}"
        
        # Add time-based rule
        if rule["time_start"] != "00:00" or rule["time_end"] != "23:59":
            cmd += f" -m time --timestart {rule['time_start']} --timestop {rule['time_end']}"
        
        # Add action
        cmd += f" -j {action}"
        
        # Add comment
        cmd += f" -m comment --comment 'Auto-generated by AI Firewall Rule-Miner'"
        
        return cmd
    
    def _generate_suricata(self, rule: Dict) -> str:
        """Generate Suricata IDS rule"""
        action = "drop" if rule["action"] == "deny" else "pass"
        
        # Suricata uses different format
        proto = rule["proto"] if rule["proto"] != "any" else "ip"
        src_ip = rule["src_ip"] if rule["src_ip"] != "any" else "any"
        dst_ip = rule["dst_ip"] if rule["dst_ip"] != "any" else "any"
        src_port = "any"
        dst_port = rule["dst_port"] if rule["dst_port"] != "any" else "any"
        
        # Build rule message
        msg = f"AI-Miner: {action} {proto}"
        if dst_port != "any":
            msg += f" port {dst_port}"
        if src_ip != "any":
            msg += f" from {src_ip}"
        
        # Build rule
        suricata_rule = f'{action} {proto} {src_ip} {src_port} -> {dst_ip} {dst_port} '
        suricata_rule += f'(msg:"{msg}"; '
        
        # Add time-based detection (Suricata doesn't natively support time, but we can note it)
        if rule["time_start"] != "00:00" or rule["time_end"] != "23:59":
            suricata_rule += f'metadata:time_window {rule["time_start"]}-{rule["time_end"]}; '
        
        # Add SID and rev
        suricata_rule += 'sid:1000001; rev:1; classtype:policy-violation;)'
        
        return suricata_rule
    
    def _generate_windows(self, rule: Dict) -> str:
        """Generate Windows Advanced Firewall PowerShell command"""
        action = "Block" if rule["action"] == "deny" else "Allow"
        
        # Build PowerShell command
        name = f"AI-Miner-Rule-{rule['proto']}-{rule['dst_port']}"
        
        cmd = f'New-NetFirewallRule -DisplayName "{name}" '
        cmd += f'-Direction Inbound -Action {action} '
        
        # Add protocol
        if rule["proto"] != "any":
            proto_map = {"tcp": "TCP", "udp": "UDP", "icmp": "ICMPv4"}
            proto = proto_map.get(rule["proto"], "Any")
            cmd += f'-Protocol {proto} '
        
        # Add port
        if rule["dst_port"] != "any":
            cmd += f'-LocalPort {rule["dst_port"]} '
        
        # Add source address
        if rule["src_ip"] != "any":
            cmd += f'-RemoteAddress {rule["src_ip"]} '
        
        # Add description
        time_note = ""
        if rule["time_start"] != "00:00" or rule["time_end"] != "23:59":
            time_note = f" (Time window: {rule['time_start']}-{rule['time_end']} - manual scheduling required)"
        
        cmd += f'-Description "Auto-generated by AI Firewall Rule-Miner{time_note}"'
        
        return cmd
    
    def load_template(self, platform: str) -> str:
        """
        Load template file for a platform (if using file-based templates)
        
        Args:
            platform: Platform name
            
        Returns:
            Template string
        """
        template_files = {
            "pfsense": "pfsense_template.xml",
            "iptables": "iptables_template.sh",
            "suricata": "suricata_template.rules",
            "windows": "windows_advfirewall_template.ps1"
        }
        
        filename = template_files.get(platform.lower())
        if not filename:
            raise ValueError(f"No template for platform: {platform}")
        
        template_path = self.template_dir / filename
        
        if not template_path.exists():
            logger.warning(f"Template file not found: {template_path}")
            return ""
        
        with open(template_path, 'r') as f:
            return f.read()
