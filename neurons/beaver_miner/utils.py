#!/usr/bin/env python3
"""
Utility functions for AI Firewall Rule-Miner
"""

import json
import logging
import os
import sys
from pathlib import Path
from typing import Dict


def setup_logging(level: str = "INFO") -> logging.Logger:
    """
    Setup logging configuration
    
    Args:
        level: Logging level (DEBUG, INFO, WARNING, ERROR)
        
    Returns:
        Configured logger
    """
    # Create logger
    logger = logging.getLogger()
    logger.setLevel(getattr(logging, level.upper(), logging.INFO))
    
    # Create console handler
    handler = logging.StreamHandler(sys.stdout)
    handler.setLevel(logging.DEBUG)
    
    # Create formatter
    formatter = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        datefmt='%H:%M:%S'
    )
    handler.setFormatter(formatter)
    
    # Add handler to logger
    if not logger.handlers:
        logger.addHandler(handler)
    
    return logger


def load_config(config_path: str = "config.json") -> Dict:
    """
    Load configuration from JSON file
    
    Args:
        config_path: Path to config file
        
    Returns:
        Configuration dictionary
    """
    if not os.path.exists(config_path):
        # Return default configuration
        default_config = {
            "llm": {
                "model_path": "models/mistral7b_int4.gguf",
                "temperature": 0.1,
                "max_tokens": 256,
                "n_ctx": 2048
            },
            "voice": {
                "duration": 5,
                "sample_rate": 16000,
                "whisper_model": "tiny"
            },
            "templates": {
                "directory": "templates"
            },
            "verifier": {
                "docker_timeout": 30
            }
        }
        
        # Save default config
        try:
            with open(config_path, 'w') as f:
                json.dump(default_config, f, indent=2)
            print(f"[+] Created default config file: {config_path}")
        except Exception as e:
            print(f"[!] Could not save default config: {e}")
        
        return default_config
    
    try:
        with open(config_path, 'r') as f:
            config = json.load(f)
        return config
    except Exception as e:
        print(f"[!] Error loading config from {config_path}: {e}")
        print("[!] Using default configuration")
        return {}


def save_rule_to_file(platform: str, rule: str, output_dir: str = "output") -> str:
    """
    Save a firewall rule to a file
    
    Args:
        platform: Platform name
        rule: Rule string
        output_dir: Output directory
        
    Returns:
        Path to saved file
    """
    # Create output directory
    Path(output_dir).mkdir(exist_ok=True)
    
    # Determine file extension
    extensions = {
        "pfsense": ".xml",
        "iptables": ".sh",
        "suricata": ".rules",
        "windows": ".ps1"
    }
    
    ext = extensions.get(platform.lower(), ".txt")
    filename = f"{platform.lower()}_rule{ext}"
    filepath = os.path.join(output_dir, filename)
    
    # Save file
    with open(filepath, 'w') as f:
        if platform.lower() == "iptables":
            # Add shebang for shell scripts
            f.write("#!/bin/bash\n")
            f.write("# Auto-generated by AI Firewall Rule-Miner\n\n")
        f.write(rule)
    
    # Make shell scripts executable
    if platform.lower() == "iptables":
        os.chmod(filepath, 0o755)
    
    return filepath


def print_banner():
    """Print application banner"""
    banner = r"""
╔══════════════════════════════════════════════════════════╗
║                                                          ║
║         AI FIREWALL RULE-MINER (MVP)                    ║
║         "Speak English, get pfSense rules"              ║
║                                                          ║
║         English → Firewall Rules in 5 seconds           ║
║                                                          ║
╚══════════════════════════════════════════════════════════╝
    """
    print(banner)


import re

def validate_json_rule(rule_json: Dict) -> bool:
    """
    Validate that a rule JSON has all required fields and they are safe.
    Uses regex to prevent command injection.
    
    Args:
        rule_json: Rule dictionary to validate
        
    Returns:
        True if valid and safe, False otherwise
    """
    required_fields = [
        "src_ip", "dst_ip", "proto", "dst_port",
        "action", "time_start", "time_end", "platform"
    ]
    
    for field in required_fields:
        if field not in rule_json:
            return False
    
    # Validation Patterns
    # IP: Supports IPv4, IPv4/Mask, or "any"
    ip_pattern = r"^(any|(\d{1,3}\.){3}\d{1,3}(/\d{1,2})?)$"
    # Port: 1-5 digits or "any"
    port_pattern = r"^(any|\d{1,5})$"
    # Proto: common protocols
    proto_pattern = r"^(any|tcp|udp|icmp|ip)$"
    # Time: HH:MM
    time_pattern = r"^\d{2}:\d{2}$"

    # Validate each field
    if not re.match(ip_pattern, str(rule_json["src_ip"]), re.I):
        return False
    if not re.match(ip_pattern, str(rule_json["dst_ip"]), re.I):
        return False
    if not re.match(port_pattern, str(rule_json["dst_port"]), re.I):
        return False
    if not re.match(proto_pattern, str(rule_json["proto"]), re.I):
        return False
    if not re.match(time_pattern, str(rule_json["time_start"])):
        return False
    if not re.match(time_pattern, str(rule_json["time_end"])):
        return False

    # Validate action
    if rule_json["action"] not in ["allow", "deny"]:
        return False
    
    return True


def format_rule_summary(rule_json: Dict) -> str:
    """
    Format a human-readable summary of a rule
    
    Args:
        rule_json: Rule dictionary
        
    Returns:
        Formatted summary string
    """
    action = rule_json.get("action", "unknown").upper()
    proto = rule_json.get("proto", "any").upper()
    src = rule_json.get("src_ip", "any")
    dst = rule_json.get("dst_ip", "any")
    port = rule_json.get("dst_port", "any")
    time_start = rule_json.get("time_start", "00:00")
    time_end = rule_json.get("time_end", "23:59")
    
    summary = f"{action} {proto}"
    
    if port != "any":
        summary += f" port {port}"
    
    if src != "any":
        summary += f" from {src}"
    
    if dst != "any":
        summary += f" to {dst}"
    
    if time_start != "00:00" or time_end != "23:59":
        summary += f" between {time_start} and {time_end}"
    
    return summary
