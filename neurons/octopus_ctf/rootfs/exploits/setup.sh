#!/bin/bash
# Container Escape Trainer - Exploit Setup Script
# This script configures 10 deliberate container misconfigurations for CTF training

set -e

echo "[*] Setting up 10 container escape paths..."

# ============================================================================
# ESCAPE 1: CAP_DAC_READ_SEARCH
# Allows bypassing file read permission checks
# ============================================================================
echo "[+] Escape 1: Granting CAP_DAC_READ_SEARCH to /bin/cat"
setcap cap_dac_read_search+ep /bin/cat 2>/dev/null || true
setcap cap_dac_read_search+ep /bin/bash 2>/dev/null || true

# ============================================================================
# ESCAPE 2: CAP_SYS_ADMIN
# Allows mount operations and other privileged syscalls
# ============================================================================
echo "[+] Escape 2: Granting CAP_SYS_ADMIN to /bin/bash"
setcap cap_sys_admin+ep /usr/bin/nsenter 2>/dev/null || true

# ============================================================================
# ESCAPE 3: Privileged Container (documented in hints)
# When run with --privileged, container has all capabilities
# ============================================================================
echo "[+] Escape 3: Creating hint for privileged container"
mkdir -p /hints
cat > /hints/03_privileged.txt <<'HINT'
ESCAPE PATH 3: Privileged Container

If this container was started with --privileged flag, you have ALL capabilities.
Try: capsh --print | grep Current

With privileged mode, you can:
- Mount host filesystems
- Access raw devices
- Modify iptables
- Load kernel modules

Check if /dev has all devices mounted.
HINT

# ============================================================================
# ESCAPE 4: Host Path Mount
# Simulates host filesystem mounted inside container
# ============================================================================
echo "[+] Escape 4: Creating /host directory structure"
mkdir -p /host
# Note: Actual host mount happens at runtime via docker run -v /:/host

# Place the flag file in expected location
mkdir -p /host
cat > /host/flag10.txt <<'FLAG'
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                      CONTAINER ESCAPE CTF                        â•‘
â•‘                         FLAG 10 / 10                             â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Congratulations! You've successfully escaped the container! ðŸŽ‰

Below is the sensitive data (fake credit card for training):

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  CREDIT CARD NUMBER: 4444-4444-4444-4444
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Now for the final challenge:
  1. Use the redact.exe tool to mask this credit card number
  2. Run: redact.exe /host/flag10.txt
  3. Wait for the auto-checker to verify redaction
  4. Receive your CTF PASS badge!

Good luck with the redaction! ðŸ”
FLAG

cat > /hints/04_hostpath.txt <<'HINT'
ESCAPE PATH 4: Host Path Mount

Many containers have host paths mounted for data persistence.
Common mount points:
- /host
- /mnt/host
- /hostfs
- /rootfs

Try: mount | grep host
Or:  ls -la /host

If you find a host mount, you can access the entire host filesystem!
Navigate to /host/flag10.txt to find the flag.
HINT

# ============================================================================
# ESCAPE 5: Docker Socket Exposure
# Docker socket inside container = full Docker control
# ============================================================================
echo "[+] Escape 5: Creating Docker socket hint"
# Note: Actual socket mount happens at runtime via -v /var/run/docker.sock:/var/run/docker.sock

cat > /hints/05_docker_socket.txt <<'HINT'
ESCAPE PATH 5: Docker Socket

If the Docker socket is mounted inside the container, you can control Docker.
Check: ls -la /var/run/docker.sock

With Docker socket access, you can:
  1. List all containers: docker ps
  2. Run a new privileged container
  3. Mount host filesystem into new container
  4. Escape to host

Example escape:
  docker run -it -v /:/host alpine chroot /host /bin/bash

This gives you a root shell on the host system!
HINT

# ============================================================================
# ESCAPE 6: PID Namespace Sharing
# Seeing host PIDs allows process manipulation
# ============================================================================
echo "[+] Escape 6: Creating PID namespace hint"
cat > /hints/06_pid_namespace.txt <<'HINT'
ESCAPE PATH 6: PID Namespace Sharing

Some containers share the host PID namespace for debugging.
Check: ps aux | grep -v containerd

If you see host processes:
- Look for processes running as root on host
- Check /proc/<pid>/root for host filesystem access
- Use nsenter to enter host namespaces

Example:
  nsenter -t 1 -m -u -n -i sh
  (Enters mount, UTS, network, and IPC namespaces of PID 1)
HINT

# ============================================================================
# ESCAPE 7: Writable Cgroup
# Cgroup manipulation can lead to privilege escalation
# ============================================================================
echo "[+] Escape 7: Creating writable cgroup paths"
mkdir -p /sys/fs/cgroup/unified 2>/dev/null || true
cat > /hints/07_cgroup.txt <<'HINT'
ESCAPE PATH 7: Writable Cgroup

Control groups (cgroups) can be exploited if writable.
Check: ls -la /sys/fs/cgroup/

If cgroup paths are writable and you can release_agent:
  1. Create a cgroup
  2. Set notify_on_release to 1
  3. Set release_agent to your script on host
  4. Trigger the release by killing all processes in cgroup
  5. Your script runs as root on host!

This is a complex exploit - search for "cgroup container escape"
HINT

# ============================================================================
# ESCAPE 8: Procfs Escape
# /proc filesystem can expose host information
# ============================================================================
echo "[+] Escape 8: Creating procfs hint"
cat > /hints/08_procfs.txt <<'HINT'
ESCAPE PATH 8: Procfs Escape

The /proc filesystem can expose paths to the host.
Interesting paths:
- /proc/1/root (often points to host root)
- /proc/self/cgroup
- /proc/self/mountinfo
- /proc/sys/kernel/core_pattern

If you can write to /proc/sys/kernel/core_pattern:
  1. Set it to: |/path/to/your/script
  2. Cause a core dump
  3. Your script executes on the host!

Check: ls -la /proc/1/root
HINT

# ============================================================================
# ESCAPE 9: Weak Seccomp Profile
# Reduced syscall filtering allows dangerous operations
# ============================================================================
echo "[+] Escape 9: Creating seccomp hint"
cat > /hints/09_seccomp.txt <<'HINT'
ESCAPE PATH 9: Weak Seccomp Profile

Seccomp restricts available syscalls. Weak/missing seccomp = more attack surface.
Check: grep Seccomp /proc/self/status

If Seccomp shows 0 (disabled) or 2 (weak filter):
- You may be able to use dangerous syscalls
- Try keyctl, bpf, ptrace, etc.
- Attempt kernel exploits (dirty cow, etc.)

This container may have weak seccomp filtering enabled.
HINT

# ============================================================================
# ESCAPE 10: No AppArmor / SELinux
# Lack of MAC (Mandatory Access Control)
# ============================================================================
echo "[+] Escape 10: Creating AppArmor hint"
cat > /hints/10_apparmor.txt <<'HINT'
ESCAPE PATH 10: No AppArmor / SELinux

AppArmor and SELinux provide mandatory access control.
Check: cat /proc/self/attr/current

If it shows "unconfined" or errors:
- No AppArmor/SELinux restricting this container
- You have more freedom to exploit other weaknesses
- Combine with other escapes for maximum impact

This container is running unconfined - easier to escape!
HINT

# ============================================================================
# Additional setup
# ============================================================================
echo "[+] Creating hints index"
cat > /hints/00_index.txt <<'INDEX'
CONTAINER ESCAPE TRAINER - Hints Index

Available hint files:
  01_capabilities.txt  - Linux capabilities (CAP_DAC_READ_SEARCH, CAP_SYS_ADMIN)
  02_reconnaissance.txt - How to gather information
  03_privileged.txt    - Privileged container escape
  04_hostpath.txt      - Host path mount escape
  05_docker_socket.txt - Docker socket escape
  06_pid_namespace.txt - PID namespace escape
  07_cgroup.txt        - Cgroup manipulation
  08_procfs.txt        - Procfs-based escape
  09_seccomp.txt       - Weak seccomp profile
  10_apparmor.txt      - No AppArmor/SELinux

Pro tip: Start with 02_reconnaissance.txt to learn what to check!
INDEX

cat > /hints/01_capabilities.txt <<'HINT'
ESCAPE PATH 1 & 2: Linux Capabilities

Check your capabilities: capsh --print

Dangerous capabilities:
- CAP_DAC_READ_SEARCH: Read any file bypassing permissions
- CAP_SYS_ADMIN: Mount filesystems, many privileged operations
- CAP_SYS_PTRACE: Attach to any process
- CAP_SYS_MODULE: Load kernel modules
- CAP_NET_ADMIN: Network configuration

This container has CAP_DAC_READ_SEARCH on /bin/cat and /bin/bash.
Use: cat /etc/shadow (normally forbidden)

For CAP_SYS_ADMIN, look at /usr/bin/nsenter
HINT

cat > /hints/02_reconnaissance.txt <<'HINT'
RECONNAISSANCE - Information Gathering

Before attempting an escape, gather intel:

1. Check capabilities:
   capsh --print

2. Check mounts:
   mount
   cat /proc/mounts

3. Check for Docker socket:
   ls -la /var/run/docker.sock

4. Check namespaces:
   ls -la /proc/self/ns/

5. Check security modules:
   cat /proc/self/attr/current
   grep Seccomp /proc/self/status

6. Check processes:
   ps aux

7. Check for host filesystem:
   ls /host
   ls /mnt

8. Check devices:
   ls -la /dev

9. Check cgroups:
   cat /proc/1/cgroup
   ls -la /sys/fs/cgroup

10. Check procfs:
    ls -la /proc/1/root

Use this information to identify which escape path to attempt!
HINT

# Set permissions
chmod 644 /hints/*.txt
chmod 644 /host/flag10.txt

echo "[*] Setup complete! 10 escape paths configured."
echo "[*] Hints available in /hints/"
echo "[*] Flag ready at /host/flag10.txt"
